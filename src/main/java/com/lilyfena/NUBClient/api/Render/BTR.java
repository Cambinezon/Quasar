package com.lilyfena.NUBClient.api.Render;


import com.ferra13671.TextureUtils.PathMode;
import com.lilyfena.NUBClient.api.FileSystem.ConfigSystem.ConfigUtils;
import com.lilyfena.NUBClient.api.Font.BThackCum.FontRenderManager;
import com.lilyfena.NUBClient.api.Font.BThackCum.FontUtils;
import com.lilyfena.NUBClient.api.Other.RegionPos;
import com.lilyfena.NUBClient.api.Render.Line.BThackLineRender;
import com.lilyfena.NUBClient.api.Render.Sphere.KappaSphereRender;
import com.lilyfena.NUBClient.api.Render.Texture.Texture;
import com.lilyfena.NUBClient.api.Utils.EntityUtils;
import com.lilyfena.NUBClient.api.Utils.RotateUtils;
import com.lilyfena.NUBClient.impl.Mc;
import com.lilyfena.NUBClient.api.Render.Box.BThackBoxRender;
import com.mojang.blaze3d.platform.GlStateManager;
import com.mojang.blaze3d.systems.RenderSystem;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.client.font.TextRenderer;
import net.minecraft.client.gui.DrawContext;
import net.minecraft.client.gui.ScreenRect;
import net.minecraft.client.render.*;
import net.minecraft.client.util.Window;
import net.minecraft.client.util.math.MatrixStack;
import net.minecraft.entity.Entity;
import net.minecraft.item.ItemStack;
import net.minecraft.util.Identifier;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Box;
import net.minecraft.util.math.ColorHelper;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.chunk.Chunk;
import org.joml.Matrix4f;

import java.awt.*;

/**
 *
 *
 *
 * @author Bebra_tyan
 * @since core
 */
public final class BTR implements Mc {

    public static final VertexConsumerProvider.Immediate bufferSource = mc.getBufferBuilders().getEntityVertexConsumers();
    public static final DrawContext guiGraphics = new DrawContext(mc, bufferSource);
    public static final BWRC worldRenderContext = new BWRC();
    public static final BThackLineRender lineRender = new BThackLineRender();
    public static final BThackBoxRender boxRender = new BThackBoxRender();
    public static final KappaSphereRender sphereRender = new KappaSphereRender();
    public static ScissorStack scissorStack = new ScissorStack();
    public static Font defualt = FontUtils.createFontNoThrow(ConfigUtils.newInputStream("assets/nubclient/other/cubic.ttf", PathMode.INSIDEJAR), 17);
    public static FontRenderManager fontRenderManager = new FontRenderManager(defualt);

    private static boolean inited = false;

    public static void init() {
        if (!inited) {
            boxRender.init();
        }
        inited = true;
    }

    public static void trace(Entity entity, MatrixStack matrixStack, float partialTicks, RegionPos region, Color color) {
        RenderSystem.setShaderColor((float)color.getRed() / 255, (float)color.getGreen() / 255, (float)color.getBlue() / 255, (float)color.getAlpha() / 255);

        Matrix4f matrix = matrixStack.peek().getPositionMatrix();
        Tessellator tessellator = RenderSystem.renderThreadTesselator();
        BufferBuilder bufferBuilder = tessellator.getBuffer();
        RenderSystem.setShader(GameRenderer::getPositionProgram);

        Vec3d regionVec = region.toVec3d();
        Vec3d start = RotateUtils.getClientLookVec(partialTicks)
                .add(BTR.getCameraPos()).subtract(regionVec);

        bufferBuilder.begin(VertexFormat.DrawMode.DEBUG_LINES,
                VertexFormats.POSITION);
        Vec3d end = EntityUtils.getLerpedBox(entity, partialTicks).getCenter()
                .subtract(new Vec3d(regionVec.x, regionVec.y, regionVec.z));

        bufferBuilder
                .vertex(matrix, (float)start.x, (float)start.y, (float)start.z)
                .next();
        bufferBuilder
                .vertex(matrix, (float)end.x, (float)end.y, (float)end.z)
                .next();
        tessellator.draw();
    }

    public static void drawRoundedRect(int x1, int y1, int x2, int y2, int radius, int color) {
        guiGraphics.fill(x1 + radius, y1, x2 - radius, y2, color);
        guiGraphics.fill(x1, y1 + radius, x1 + radius, y2 - radius, color);
        guiGraphics.fill(x2 - radius, y1 + radius, x2, y2 - radius, color);
        guiGraphics.fill(x1 + radius, y1, x2 - radius, y1 + radius, color);
        guiGraphics.fill(x1 + radius, y2 - radius, x2 - radius, y2, color);
        guiGraphics.fill(x1, y1, x1 + radius, y1 + radius, color);
        guiGraphics.fill(x2 - radius, y1, x2, y1 + radius, color);
        guiGraphics.fill(x1, y2 - radius, x1 + radius, y2, color);
        guiGraphics.fill(x2 - radius, y2 - radius, x2, y2, color);
    }

    //Just a simplified line renderer, so as not to waste CPU time on constant data retrieval.
    public static void trace(Entity entity, Matrix4f matrix, float partialTicks, Color color, Tessellator tessellator, BufferBuilder bufferBuilder, Vec3d regionVec) {
        RenderSystem.setShaderColor((float)color.getRed() / 255, (float)color.getGreen() / 255, (float)color.getBlue() / 255, (float)color.getAlpha() / 255);

        Vec3d start = RotateUtils.getClientLookVec(partialTicks)
                .add(BTR.getCameraPos()).subtract(regionVec);
        bufferBuilder.begin(VertexFormat.DrawMode.DEBUG_LINES,
                VertexFormats.POSITION);
        Vec3d end = EntityUtils.getLerpedBox(entity, partialTicks).getCenter()
                .subtract(new Vec3d(regionVec.x, regionVec.y, regionVec.z));
        bufferBuilder
                .vertex(matrix, (float)start.x, (float)start.y, (float)start.z)
                .next();
        bufferBuilder
                .vertex(matrix, (float)end.x, (float)end.y, (float)end.z)
                .next();
        tessellator.draw();
    }

    public static void trace(BlockEntity entity, Matrix4f matrix, float partialTicks, Color color, Tessellator tessellator, BufferBuilder bufferBuilder, Vec3d regionVec) {
        Box box = EntityUtils.getLerpedBox(entity, partialTicks);

        if (box == null) return;

        RenderSystem.setShaderColor((float)color.getRed() / 255, (float)color.getGreen() / 255, (float)color.getBlue() / 255, (float)color.getAlpha() / 255);

        Vec3d start = RotateUtils.getClientLookVec(partialTicks)
                .add(BTR.getCameraPos()).subtract(regionVec);
        bufferBuilder.begin(VertexFormat.DrawMode.DEBUG_LINES,
                VertexFormats.POSITION);

        Vec3d end = box.getCenter()
                .subtract(new Vec3d(regionVec.x, regionVec.y, regionVec.z));
        bufferBuilder
                .vertex(matrix, (float)start.x, (float)start.y, (float)start.z)
                .next();
        bufferBuilder
                .vertex(matrix, (float)end.x, (float)end.y, (float)end.z)
                .next();
        tessellator.draw();
    }

    public static void trace(Vec3d vec3d, Matrix4f matrix, float partialTicks, float red, float green, float blue, float alpha, Tessellator tessellator, BufferBuilder bufferBuilder, Vec3d regionVec) {
        RenderSystem.setShaderColor(red, green, blue, alpha);

        Vec3d start = RotateUtils.getClientLookVec(partialTicks)
                .add(BTR.getCameraPos()).subtract(regionVec);
        bufferBuilder.begin(VertexFormat.DrawMode.DEBUG_LINES,
                VertexFormats.POSITION);

        Vec3d end = vec3d
                .subtract(new Vec3d(regionVec.x, regionVec.y, regionVec.z));
        bufferBuilder
                .vertex(matrix, (float)start.x, (float)start.y, (float)start.z)
                .next();
        bufferBuilder
                .vertex(matrix, (float)end.x, (float)end.y, (float)end.z)
                .next();
        tessellator.draw();
    }

    public static void drawActualLine(Vec3d vec3d, Vec3d start, Matrix4f matrix, float red, float green, float blue, float alpha, Tessellator tessellator, BufferBuilder bufferBuilder, Vec3d regionVec) {
        RenderSystem.setShaderColor(red, green, blue, alpha);

        start = start.subtract(regionVec);
        bufferBuilder.begin(VertexFormat.DrawMode.DEBUG_LINES,
                VertexFormats.POSITION);

        Vec3d end = vec3d
                .subtract(new Vec3d(regionVec.x, regionVec.y, regionVec.z));
        bufferBuilder
                .vertex(matrix, (float)start.x, (float)start.y, (float)start.z)
                .next();
        bufferBuilder
                .vertex(matrix, (float)end.x, (float)end.y, (float)end.z)
                .next();
        tessellator.draw();
    }

    public static void dr(float x1, float y1, float x2, float y2, int color) {
        drawRect(x1, y1, x2, y2, color, guiGraphics.getMatrices().peek().getPositionMatrix());
    }

    public static void drawRect(float x1, float y1, float x2, float y2, int color, Matrix4f matrix4f) {
        if (x1 < x2) {
            float i = x1;
            x1 = x2;
            x2 = i;
        }

        if (y1 < y2) {
            float j = y1;
            y1 = y2;
            y2 = j;
        }

        float r = (float) ColorHelper.Argb.getRed(color) / 255.0F;
        float g = (float) ColorHelper.Argb.getGreen(color) / 255.0F;
        float b = (float) ColorHelper.Argb.getBlue(color) / 255.0F;
        float a = (float) ColorHelper.Argb.getAlpha(color) / 255.0F;

        Tessellator tessellator = RenderSystem.renderThreadTesselator();
        BufferBuilder buffer = tessellator.getBuffer();
        RenderSystem.setShader(GameRenderer::getPositionColorProgram);

        RenderSystem.enableBlend();
        RenderSystem.blendFunc(GlStateManager.SrcFactor.SRC_ALPHA, GlStateManager.DstFactor.ONE_MINUS_SRC_ALPHA);
        //RenderSystem.blendFuncSeparate(GlStateManager.SrcFactor.SRC_ALPHA, GlStateManager.DstFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SrcFactor.ONE, GlStateManager.DstFactor.ZERO);
        //GlStateManager._blendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);

        buffer.begin(VertexFormat.DrawMode.QUADS, VertexFormats.POSITION_COLOR);

        //вправо-вниз
        buffer.vertex(matrix4f, x1, y1, (float)0).color(r, g, b, a).next();
        //врапо-вверх
        buffer.vertex(matrix4f, x1, y2, (float)0).color(r, g, b, a).next();
        //влево-вверх
        buffer.vertex(matrix4f, x2, y2, (float)0).color(r, g, b, a).next();
        //влево-вниз
        buffer.vertex(matrix4f, x2, y1, (float)0).color(r, g, b, a).next();

        BufferRenderer.drawWithGlobalProgram(buffer.end());

        RenderSystem.disableBlend();
    }

    public static void drawLine(float x1, float y1, float x2, float y2, float wight, int color) {

        Matrix4f matrix4f = guiGraphics.getMatrices().peek().getPositionMatrix();

        if (x1 > x2) {
            float i = x1;
            x1 = x2;
            x2 = i;
        }

        if (y1 > y2) {
            float j = y1;
            y1 = y2;
            y2 = j;
        }

        wight = wight / 2;

        float f = (float) ColorHelper.Argb.getAlpha(color) / 255.0F;
        float g = (float) ColorHelper.Argb.getRed(color) / 255.0F;
        float h = (float) ColorHelper.Argb.getGreen(color) / 255.0F;
        float j = (float) ColorHelper.Argb.getBlue(color) / 255.0F;
        VertexConsumer vertexconsumer = bufferSource.getBuffer(RenderLayer.getGui());
        //вправо-вниз
        vertexconsumer.vertex(matrix4f, x2 + wight, y2 + wight, (float)0).color(g, h, j, f).next();
        //врапо-вверх
        vertexconsumer.vertex(matrix4f, x2 + wight, y2 - wight, (float)0).color(g, h, j, f).next();
        //влево-вверх
        vertexconsumer.vertex(matrix4f, x1 - wight, y1 - wight, (float)0).color(g, h, j, f).next();
        //влево-вниз
        vertexconsumer.vertex(matrix4f, x1 - wight, y1 + wight, (float)0).color(g, h, j, f).next();
        guiGraphics.draw();
    }

    public static void drawVerticalGradientRect(float x1, float y1, float x2, float y2, int startColor, int endColor) {
        float f = (float) ColorHelper.Argb.getAlpha(startColor) / 255.0F;
        float f1 = (float) ColorHelper.Argb.getRed(startColor) / 255.0F;
        float f2 = (float)ColorHelper.Argb.getGreen(startColor) / 255.0F;
        float f3 = (float) ColorHelper.Argb.getBlue(startColor) / 255.0F;
        float f4 = (float) ColorHelper.Argb.getAlpha(endColor) / 255.0F;
        float f5 = (float) ColorHelper.Argb.getRed(endColor) / 255.0F;
        float f6 = (float) ColorHelper.Argb.getGreen(endColor) / 255.0F;
        float f7 = (float) ColorHelper.Argb.getBlue(endColor) / 255.0F;
        Matrix4f matrix4f = guiGraphics.getMatrices().peek().getPositionMatrix();
        VertexConsumer vertexConsumer = bufferSource.getBuffer(RenderLayer.getGui());
        vertexConsumer.vertex(matrix4f, x1, y1, (float)0).color(f1, f2, f3, f).next();
        vertexConsumer.vertex(matrix4f, x1, y2, (float)0).color(f5, f6, f7, f4).next();
        vertexConsumer.vertex(matrix4f, x2, y2, (float)0).color(f5, f6, f7, f4).next();
        vertexConsumer.vertex(matrix4f, x2, y1, (float)0).color(f1, f2, f3, f).next();
        guiGraphics.draw();
    }

    public static void drawHorizontalGradientRect(float x1, float y1, float x2, float y2, int startColor, int endColor) {
        float startAlpha = (float) ColorHelper.Argb.getAlpha(startColor) / 255.0F;
        float startRed = (float) ColorHelper.Argb.getRed(startColor) / 255.0F;
        float startGreen = (float) ColorHelper.Argb.getGreen(startColor) / 255.0F;
        float startBlue = (float) ColorHelper.Argb.getBlue(startColor) / 255.0F;

        float endAlpha = (float) ColorHelper.Argb.getAlpha(endColor) / 255.0F;
        float endRed = (float) ColorHelper.Argb.getRed(endColor) / 255.0F;
        float endGreen = (float) ColorHelper.Argb.getGreen(endColor) / 255.0F;
        float endBlue = (float) ColorHelper.Argb.getBlue(endColor) / 255.0F;
        Matrix4f matrix4f = guiGraphics.getMatrices().peek().getPositionMatrix();
        VertexConsumer vertexConsumer = bufferSource.getBuffer(RenderLayer.getGui());
        vertexConsumer.vertex(matrix4f, x1, y1, (float)0).color(startRed, startGreen, startBlue, startAlpha).next();
        vertexConsumer.vertex(matrix4f, x1, y2, (float)0).color(startRed, startGreen, startBlue, startAlpha).next();
        vertexConsumer.vertex(matrix4f, x2, y2, (float)0).color(endRed, endGreen, endBlue, endAlpha).next();
        vertexConsumer.vertex(matrix4f,  x2, y1, (float)0).color(endRed, endGreen, endBlue, endAlpha).next();
        guiGraphics.draw();
    }

    public static void draw4ColorRect(float x1, float y1, float x2, float y2, int x1y1Color, int x2y1Color, int x1y2Color, int x2y2Color) {
        float x1y1Alpha = (float) ColorHelper.Argb.getAlpha(x1y1Color) / 255.0F;
        float x1y1Red = (float) ColorHelper.Argb.getRed(x1y1Color) / 255.0F;
        float x1y1Green = (float) ColorHelper.Argb.getGreen(x1y1Color) / 255.0F;
        float x1y1Blue = (float) ColorHelper.Argb.getBlue(x1y1Color) / 255.0F;

        float x2y1Alpha = (float) ColorHelper.Argb.getAlpha(x2y1Color) / 255.0F;
        float x2y1Red = (float) ColorHelper.Argb.getRed(x2y1Color) / 255.0F;
        float x2y1Green = (float) ColorHelper.Argb.getGreen(x2y1Color) / 255.0F;
        float x2y1Blue = (float) ColorHelper.Argb.getBlue(x2y1Color) / 255.0F;

        float x1y2Alpha = (float) ColorHelper.Argb.getAlpha(x1y2Color) / 255.0F;
        float x1y2Red = (float) ColorHelper.Argb.getRed(x1y2Color) / 255.0F;
        float x1y2Green = (float) ColorHelper.Argb.getGreen(x1y2Color) / 255.0F;
        float x1y2Blue = (float) ColorHelper.Argb.getBlue(x1y2Color) / 255.0F;

        float x2y2Alpha = (float) ColorHelper.Argb.getAlpha(x2y2Color) / 255.0F;
        float x2y2Red = (float) ColorHelper.Argb.getRed(x2y2Color) / 255.0F;
        float x2y2Green = (float) ColorHelper.Argb.getGreen(x2y2Color) / 255.0F;
        float x2y2Blue = (float) ColorHelper.Argb.getBlue(x2y2Color) / 255.0F;

        Matrix4f matrix4f = guiGraphics.getMatrices().peek().getPositionMatrix();
        VertexConsumer vertexConsumer = bufferSource.getBuffer(RenderLayer.getGui());
        vertexConsumer.vertex(matrix4f, x1, y1, (float)0).color(x1y1Red, x1y1Green, x1y1Blue, x1y1Alpha).next();
        vertexConsumer.vertex(matrix4f, x1, y2, (float)0).color(x1y2Red, x1y2Green, x1y2Blue, x1y2Alpha).next();
        vertexConsumer.vertex(matrix4f, x2, y2, (float)0).color(x2y2Red, x2y2Green, x2y2Blue, x2y2Alpha).next();
        vertexConsumer.vertex(matrix4f, x2, y1, (float)0).color(x2y1Red, x2y1Green, x2y1Blue, x2y1Alpha).next();
        guiGraphics.draw();
    }

    public static void Scissor(int x1, int y1, int x2, int y2) {
        enableScissor(x1,y1,x2-x1,y2-y1);
    }

    public static void enableScissor(int x, int y, int width, int height) {
        setScissor(scissorStack.push(new ScreenRect(x, y, width, height)));
    }

    public static void disableScissor() {
        setScissor(scissorStack.pop());
    }

    private static void setScissor(ScreenRect rect) {
        if (rect != null) {
            Window window = mc.getWindow();
            int i = window.getFramebufferHeight();
            double d = window.getScaleFactor();
            double e = (double) rect.getLeft() * d;
            double f = (double) i - (double) rect.getBottom() * d;
            double g = (double) rect.width() * d;
            double h = (double) rect.height() * d;
            RenderSystem.enableScissor((int) e, (int) f, Math.max(0, (int) g), Math.max(0, (int) h));
        } else {
            RenderSystem.disableScissor();
        }
    }

    public static void drawOutlineRect(float x1, float y1, float x2, float y2, float depth, int colour) {
        float outlineX;
        float outlineY;
        outlineX = x1 > x2 ? -depth : depth;
        outlineY = y1 > y2 ? depth : -depth;

        dr(x1,y1, x1 + outlineX, y2, colour);
        dr(x1 + outlineX, y2, x2, y2 + outlineY, colour);
        dr(x2, y2 + outlineY, x2 - outlineX, y1, colour);
        dr(x2 - outlineX, y1, x1, y1 - outlineY, colour);
    }

    public static void drawSquare(float x1, float y1, float size, int color) {
        Matrix4f matrix4f = guiGraphics.getMatrices().peek().getPositionMatrix();

        float f3 = (float) ColorHelper.Argb.getAlpha(color) / 255.0F;
        float f = (float) ColorHelper.Argb.getRed(color) / 255.0F;
        float f1 = (float) ColorHelper.Argb.getGreen(color) / 255.0F;
        float f2 = (float) ColorHelper.Argb.getBlue(color) / 255.0F;
        VertexConsumer vertexconsumer = bufferSource.getBuffer(RenderLayer.getGui());
        vertexconsumer.vertex(matrix4f, x1 - size, y1 - size, (float)0).color(f, f1, f2, f3).next();
        vertexconsumer.vertex(matrix4f, x1 - size, y1 + size, (float)0).color(f, f1, f2, f3).next();
        vertexconsumer.vertex(matrix4f, x1 + size, y1 + size, (float)0).color(f, f1, f2, f3).next();
        vertexconsumer.vertex(matrix4f, x1 + size, y1 - size, (float)0).color(f, f1, f2, f3).next();
        guiGraphics.draw();
    }


    public static void drawTriangle(float x, float y, float size, float theta, int color) {
        double radians = Math.toRadians(theta);

        float xA = -size;
        float yA = size;
        double newXA = xA * Math.cos(radians) + yA * Math.sin(radians);
        double newYA = yA * Math.cos(radians) - xA * Math.sin(radians);

        float xB = 0;
        float yB = -(size * 2);
        double newXB = xB * Math.cos(radians) + yB * Math.sin(radians);
        double newYB = yB * Math.cos(radians) - xB * Math.sin(radians);

        float xC = size;
        float yC = size;
        double newXC = xC * Math.cos(radians) + yC * Math.sin(radians);
        double newYC = yC * Math.cos(radians) - xC * Math.sin(radians);


        Matrix4f matrix4f = guiGraphics.getMatrices().peek().getPositionMatrix();

        float f3 = (float) ColorHelper.Argb.getAlpha(color) / 255.0F;
        float f = (float) ColorHelper.Argb.getRed(color) / 255.0F;
        float f1 = (float) ColorHelper.Argb.getGreen(color) / 255.0F;
        float f2 = (float) ColorHelper.Argb.getBlue(color) / 255.0F;
        VertexConsumer vertexconsumer = bufferSource.getBuffer(RenderLayer.getGui());
        vertexconsumer.vertex(matrix4f, (float)(x + newXB), (float)(y + newYB), (float)0).color(f, f1, f2, f3).next();
        vertexconsumer.vertex(matrix4f, (float)(x + newXA), (float)(y + newYA), (float)0).color(f, f1, f2, f3).next();
        vertexconsumer.vertex(matrix4f, (float)(x + newXC), (float)(y + newYC), (float)0).color(f, f1, f2, f3).next();
        vertexconsumer.vertex(matrix4f, (float)(x + newXB), (float)(y + newYB), (float)0).color(f, f1, f2, f3).next();
        guiGraphics.draw();


    }

    public static int drawString(String text, float x1, float y1, int color, boolean shadow, float size) {

        if (text == null || text.isEmpty()) return 0;

        guiGraphics.getMatrices().push();
        guiGraphics.getMatrices().scale(size, size, size);
        int i = mc.textRenderer.draw(text, x1 * (1 / size), y1 * (1 / size), color, shadow, guiGraphics.getMatrices().peek().getPositionMatrix(), guiGraphics.getVertexConsumers(), TextRenderer.TextLayerType.NORMAL, 0, 15728880, mc.textRenderer.isRightToLeft());
        guiGraphics.draw();
        guiGraphics.getMatrices().pop();
        return i;
    }

//    /**
//     * THE SHADER MUST HAVE VERTEXFORMAT = VERTEXFORMATS.POSITION!!!!
//     */
//    public static void drawShader(ShaderProgram shaderProgram, float x1, float y1, float x2, float y2) {
//        Matrix4f matrix4f = guiGraphics.getMatrices().peek().getPositionMatrix();
//
//        guiGraphics.getMatrices().push();
//        shaderProgram.use();
//        BufferBuilder bufferBuilder = Tessellator.getInstance().getBuffer();
//        bufferBuilder.begin(VertexFormat.DrawMode.QUADS, VertexFormats.POSITION);
//        bufferBuilder.vertex(matrix4f, x1, y2, 0.0f).next();
//        bufferBuilder.vertex(matrix4f, x2, y2, 0.0f).next();
//        bufferBuilder.vertex(matrix4f, x2, y1, 0.0f).next();
//        bufferBuilder.vertex(matrix4f, x1, y1, 0.0f).next();
//        draw();
//        shaderProgram.release();
//        guiGraphics.getMatrices().pop();
//        //RenderSystem.setShader(GameRenderer::getPositionProgram);
//    }

    public static int drawString(String text, float x1, float y1, int color, boolean shadow) {
        return drawString(text, x1, y1, color, shadow, 1);
    }

    public static int drawString(String text, float x1, float y1, int color) {
        return drawString(text, x1, y1, color, true);
    }

    public static void drawCenteredString(String text, int x1, int y1, int color) {
        guiGraphics.drawText(mc.textRenderer, text, x1 - mc.textRenderer.getWidth(text) / 2, y1 - mc.textRenderer.fontHeight /2, color, true);
    }

    public static void drawCenteredString(String text, float x1, float y1, int color, float size) {
        guiGraphics.getMatrices().push();
        guiGraphics.getMatrices().scale(size, size, size);
        guiGraphics.drawText(mc.textRenderer, text, (int) ((x1) * (1 / size) - (mc.textRenderer.getWidth(text) / 2)), (int) (y1 * (1 / size)), color, true);
        guiGraphics.getMatrices().pop();
    }



    public static void drawTextureRect(Identifier texture, float x1, float y1, float x2, float y2) {
        RenderSystem.setShaderTexture(0, texture);
        RenderSystem.setShader(GameRenderer::getPositionTexProgram);
        Matrix4f matrix4f = guiGraphics.getMatrices().peek().getPositionMatrix();
        BufferBuilder bufferBuilder = Tessellator.getInstance().getBuffer();
        bufferBuilder.begin(VertexFormat.DrawMode.QUADS, VertexFormats.POSITION_TEXTURE);
        bufferBuilder.vertex(matrix4f, x1, y2, 0.0f).texture(0, 1).next();
        bufferBuilder.vertex(matrix4f, x2, y2, 0.0f).texture(1, 1).next();
        bufferBuilder.vertex(matrix4f, x2, y1, 0.0f).texture(1, 0).next();
        bufferBuilder.vertex(matrix4f, x1, y1, 0.0f).texture(0, 0).next();
        BufferRenderer.drawWithGlobalProgram(bufferBuilder.end());
    }

//    public static void drawHorizontalRainbowRect(float x1, float y1, float x2, float y2, int rainbowType) {
//        float counter = 1;
//        float dX;
//        float tX = x1;
//        int delay = (int) RainbowUtils.getRainbowRectSpeed(rainbowType)[1];
//        float speed = RainbowUtils.getRainbowRectSpeed(rainbowType)[0];
//
//        float fX;
//
//        fX = x2 - x1;
//        fX /= 45;
//        dX = fX != 0 ? (int) Math.ceil(fX) : 0;
//
//        Tessellator tessellator = Tessellator.getInstance();
//        Shaders.INSTANCE.POSITION.use();
//        applyBlend();
//        Matrix4f matrix4f = guiGraphics.getMatrices().peek().getPositionMatrix();
//
//        while (tX != x2) {
//            if (x1 < x2) {
//                if (tX + dX > x2) {
//                    dX = x2 - tX;
//                }
//            } else {
//                if (tX + dX < x2) {
//                    dX = tX - x2;
//                }
//            }
//
//            int color = ColorUtils.rainbow((int)(counter * delay), speed);
//            float[] c = hashCodeToRGBA(color);
//
//            Shaders.INSTANCE.POSITION.setUniformValue("color", c[0], c[1], c[2], c[3]);
//            Drawers.RECT.beginBuffer(tessellator);
//
//            Drawers.RECT.vertex(matrix4f, tX, y1, 0);
//            Drawers.RECT.vertex(matrix4f, tX, y2, 0);
//            Drawers.RECT.vertex(matrix4f, tX + dX, y2, 0);
//            Drawers.RECT.vertex(matrix4f, tX + dX, y1, 0);
//
//            Drawers.RECT.endNoReset();
//
//            tX += dX;
//            counter++;
//        }
//    }


    public static void drawTextureRect(Texture texture, float x1, float y1, float x2, float y2) {
        RenderSystem.setShaderTexture(0, texture.getTexId());
        RenderSystem.setShader(GameRenderer::getPositionTexProgram);
        Matrix4f matrix4f = guiGraphics.getMatrices().peek().getPositionMatrix();
        BufferBuilder bufferBuilder = Tessellator.getInstance().getBuffer();
        bufferBuilder.begin(VertexFormat.DrawMode.QUADS, VertexFormats.POSITION_TEXTURE);
        bufferBuilder.vertex(matrix4f, x1, y2, 0.0f).texture(0, 1).next();
        bufferBuilder.vertex(matrix4f, x2, y2, 0.0f).texture(1, 1).next();
        bufferBuilder.vertex(matrix4f, x2, y1, 0.0f).texture(1, 0).next();
        bufferBuilder.vertex(matrix4f, x1, y1, 0.0f).texture(0, 0).next();
        BufferRenderer.drawWithGlobalProgram(bufferBuilder.end());
    }

    public static void drawItem(DrawContext context, ItemStack stack, int x, int y, String amountText, boolean onSlot) {
        context.getMatrices().push();
        context.getMatrices().translate(0.0f, 0.0f, 232.0f);
        context.drawItem(stack, x, y);
        if (onSlot)
            context.drawItemInSlot(mc.textRenderer, stack, x, y, amountText);
        context.getMatrices().pop();
    }

    public static BlockPos getCameraBlockPos() {
        Camera camera = mc.getBlockEntityRenderDispatcher().camera;
        if(camera == null)
            return BlockPos.ORIGIN;

        return camera.getBlockPos();
    }

    public static Vec3d getCameraPos() {
        Camera camera = mc.getBlockEntityRenderDispatcher().camera;
        if(camera == null)
            return Vec3d.ZERO;

        return camera.getPos();
    }

    public static RegionPos getCameraRegion() {
        return RegionPos.of(getCameraBlockPos());
    }

    public static void applyRegionalRenderOffset(MatrixStack matrixStack) {
        applyRegionalRenderOffset(matrixStack, getCameraRegion());
    }

    public static void applyRegionalRenderOffset(MatrixStack matrixStack, Chunk chunk) {
        applyRegionalRenderOffset(matrixStack, RegionPos.of(chunk.getPos()));
    }

    public static void applyRegionalRenderOffset(MatrixStack matrixStack, RegionPos region) {
        Vec3d offset = region.toVec3d().subtract(getCameraPos());
        matrixStack.translate(offset.x, offset.y, offset.z);
    }
}
